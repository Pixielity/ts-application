{"version":3,"sources":["../../../src/container/middleware/logger-middleware.ts","../../../src/container/middleware/cache-middleware.ts","../../../src/container/metrics/metrics.ts","../../../src/container/middleware/metrics-middleware.ts"],"names":["value"],"mappings":"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","file":"index.js","sourcesContent":["import type { interfaces } from \"inversify\"\n\n/**\n * Create a logger middleware for the Inversify container\n *\n * @param logger - The logger function (defaults to console.log)\n * @returns The logger middleware\n */\nexport function loggerMiddleware(logger: (message: string) => void = console.log): interfaces.Middleware {\n  return (next: interfaces.Next) => {\n    return (args: interfaces.NextArgs) => {\n      const { serviceIdentifier } = args\n      const id = serviceIdentifier.toString()\n\n      logger(`Resolving: ${id}`)\n\n      const result = next(args)\n\n      logger(`Resolved: ${id}`)\n\n      return result\n    }\n  }\n}\n","import type { interfaces } from 'inversify'\n\n/**\n * Create a cache middleware for the Inversify container\n *\n * @param shouldCache - Function to determine if a service should be cached (defaults to true for all)\n * @returns The cache middleware\n */\nexport function cacheMiddleware(\n  shouldCache: (serviceIdentifier: interfaces.ServiceIdentifier<any>) => boolean = () => true,\n): interfaces.Middleware {\n  const cache = new Map<interfaces.ServiceIdentifier<any>, any>()\n\n  return (next: interfaces.Next) => {\n    return (args: interfaces.NextArgs) => {\n      const { serviceIdentifier } = args\n\n      // Check if the service is already cached\n      if (cache.has(serviceIdentifier)) {\n        return cache.get(serviceIdentifier)\n      }\n\n      // Get the result from the next middleware\n      const result = next(args)\n\n      // Cache the result if needed\n      if (shouldCache(serviceIdentifier)) {\n        cache.set(serviceIdentifier, result)\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Create a cache middleware with a flush method\n *\n * @param shouldCache - Function to determine if a service should be cached\n * @returns The cache middleware and flush function\n */\nexport function createCacheMiddleware(\n  shouldCache?: (serviceIdentifier: interfaces.ServiceIdentifier<any>) => boolean,\n): {\n  middleware: interfaces.Middleware\n  flush: (serviceIdentifier?: interfaces.ServiceIdentifier<any>) => void\n} {\n  const cache = new Map<interfaces.ServiceIdentifier<any>, any>()\n\n  const middleware = (next: interfaces.Next) => {\n    return (args: interfaces.NextArgs) => {\n      const { serviceIdentifier } = args\n\n      // Check if the service is already cached\n      if (cache.has(serviceIdentifier)) {\n        return cache.get(serviceIdentifier)\n      }\n\n      // Get the result from the next middleware\n      const result = next(args)\n\n      // Cache the result if needed\n      if (!shouldCache || shouldCache(serviceIdentifier)) {\n        cache.set(serviceIdentifier, result)\n      }\n\n      return result\n    }\n  }\n\n  const flush = (serviceIdentifier?: interfaces.ServiceIdentifier<any>) => {\n    if (serviceIdentifier) {\n      cache.delete(serviceIdentifier)\n    } else {\n      cache.clear()\n    }\n  }\n\n  return { middleware, flush }\n}\n","import { IMetricsCollector } from './metrics.interface'\n\n/**\n * Default metrics collector that logs to console\n */\nexport class MetricsCollector implements IMetricsCollector {\n  /**\n   * Create a new Metrics Collector instance.\n   *\n   * @returns A new Metrics Collector instance\n   */\n  public static make(): IMetricsCollector {\n    return new MetricsCollector()\n  }\n\n  /**\n   * Record a timing metric\n   *\n   * @param name - The metric name\n   * @param value - The metric value\n   * @param tags - The metric tags\n   */\n  public timing(name: string, value: number, tags: Record<string, string> = {}): void {\n    const tagsString = Object.entries(tags)\n      .map(([key, value]) => `${key}=${value}`)\n      .join(',')\n\n    console.log(`TIMING ${name}=${value}ms ${tagsString}`)\n  }\n\n  /**\n   * Increment a counter metric\n   *\n   * @param name - The metric name\n   * @param value - The increment value\n   * @param tags - The metric tags\n   */\n  public increment(name: string, value = 1, tags: Record<string, string> = {}): void {\n    const tagsString = Object.entries(tags)\n      .map(([key, value]) => `${key}=${value}`)\n      .join(',')\n\n    console.log(`COUNT ${name}=${value} ${tagsString}`)\n  }\n}\n","import type { interfaces } from 'inversify'\nimport { MetricsCollector } from '../metrics'\n\n/**\n * Create a metrics middleware for the Inversify container\n *\n * @param collector - The metrics collector\n * @returns The metrics middleware\n */\nexport function metricsMiddleware(\n  collector: MetricsCollector = MetricsCollector.make(),\n): interfaces.Middleware {\n  return (next: interfaces.Next) => {\n    return (args: interfaces.NextArgs) => {\n      const { serviceIdentifier } = args\n      const id = serviceIdentifier.toString()\n\n      // Increment the resolution counter\n      collector.increment('container.resolution', 1, {\n        service: id,\n      })\n\n      // Measure the resolution time\n      const startTime = Date.now()\n\n      const result = next(args)\n\n      const endTime = Date.now()\n      const duration = endTime - startTime\n\n      // Record the resolution time\n      collector.timing('container.resolution_time', duration, {\n        service: id,\n      })\n\n      return result\n    }\n  }\n}\n"]}