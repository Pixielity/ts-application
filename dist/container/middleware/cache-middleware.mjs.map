{"version":3,"sources":["../../../src/container/middleware/cache-middleware.ts"],"names":[],"mappings":";AAQO,SAAS,eAAA,CACd,WAAiF,GAAA,MAAM,IAChE,EAAA;AACvB,EAAM,MAAA,KAAA,uBAAY,GAA4C,EAAA;AAE9D,EAAA,OAAO,CAAC,IAA0B,KAAA;AAChC,IAAA,OAAO,CAAC,IAA8B,KAAA;AACpC,MAAM,MAAA,EAAE,mBAAsB,GAAA,IAAA;AAG9B,MAAI,IAAA,KAAA,CAAM,GAAI,CAAA,iBAAiB,CAAG,EAAA;AAChC,QAAO,OAAA,KAAA,CAAM,IAAI,iBAAiB,CAAA;AAAA;AAIpC,MAAM,MAAA,MAAA,GAAS,KAAK,IAAI,CAAA;AAGxB,MAAI,IAAA,WAAA,CAAY,iBAAiB,CAAG,EAAA;AAClC,QAAM,KAAA,CAAA,GAAA,CAAI,mBAAmB,MAAM,CAAA;AAAA;AAGrC,MAAO,OAAA,MAAA;AAAA,KACT;AAAA,GACF;AACF;AAQO,SAAS,sBACd,WAIA,EAAA;AACA,EAAM,MAAA,KAAA,uBAAY,GAA4C,EAAA;AAE9D,EAAM,MAAA,UAAA,GAAa,CAAC,IAA0B,KAAA;AAC5C,IAAA,OAAO,CAAC,IAA8B,KAAA;AACpC,MAAM,MAAA,EAAE,mBAAsB,GAAA,IAAA;AAG9B,MAAI,IAAA,KAAA,CAAM,GAAI,CAAA,iBAAiB,CAAG,EAAA;AAChC,QAAO,OAAA,KAAA,CAAM,IAAI,iBAAiB,CAAA;AAAA;AAIpC,MAAM,MAAA,MAAA,GAAS,KAAK,IAAI,CAAA;AAGxB,MAAA,IAAI,CAAC,WAAA,IAAe,WAAY,CAAA,iBAAiB,CAAG,EAAA;AAClD,QAAM,KAAA,CAAA,GAAA,CAAI,mBAAmB,MAAM,CAAA;AAAA;AAGrC,MAAO,OAAA,MAAA;AAAA,KACT;AAAA,GACF;AAEA,EAAM,MAAA,KAAA,GAAQ,CAAC,iBAA0D,KAAA;AACvE,IAAA,IAAI,iBAAmB,EAAA;AACrB,MAAA,KAAA,CAAM,OAAO,iBAAiB,CAAA;AAAA,KACzB,MAAA;AACL,MAAA,KAAA,CAAM,KAAM,EAAA;AAAA;AACd,GACF;AAEA,EAAO,OAAA,EAAE,YAAY,KAAM,EAAA;AAC7B","file":"cache-middleware.mjs","sourcesContent":["import type { interfaces } from 'inversify'\n\n/**\n * Create a cache middleware for the Inversify container\n *\n * @param shouldCache - Function to determine if a service should be cached (defaults to true for all)\n * @returns The cache middleware\n */\nexport function cacheMiddleware(\n  shouldCache: (serviceIdentifier: interfaces.ServiceIdentifier<any>) => boolean = () => true,\n): interfaces.Middleware {\n  const cache = new Map<interfaces.ServiceIdentifier<any>, any>()\n\n  return (next: interfaces.Next) => {\n    return (args: interfaces.NextArgs) => {\n      const { serviceIdentifier } = args\n\n      // Check if the service is already cached\n      if (cache.has(serviceIdentifier)) {\n        return cache.get(serviceIdentifier)\n      }\n\n      // Get the result from the next middleware\n      const result = next(args)\n\n      // Cache the result if needed\n      if (shouldCache(serviceIdentifier)) {\n        cache.set(serviceIdentifier, result)\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Create a cache middleware with a flush method\n *\n * @param shouldCache - Function to determine if a service should be cached\n * @returns The cache middleware and flush function\n */\nexport function createCacheMiddleware(\n  shouldCache?: (serviceIdentifier: interfaces.ServiceIdentifier<any>) => boolean,\n): {\n  middleware: interfaces.Middleware\n  flush: (serviceIdentifier?: interfaces.ServiceIdentifier<any>) => void\n} {\n  const cache = new Map<interfaces.ServiceIdentifier<any>, any>()\n\n  const middleware = (next: interfaces.Next) => {\n    return (args: interfaces.NextArgs) => {\n      const { serviceIdentifier } = args\n\n      // Check if the service is already cached\n      if (cache.has(serviceIdentifier)) {\n        return cache.get(serviceIdentifier)\n      }\n\n      // Get the result from the next middleware\n      const result = next(args)\n\n      // Cache the result if needed\n      if (!shouldCache || shouldCache(serviceIdentifier)) {\n        cache.set(serviceIdentifier, result)\n      }\n\n      return result\n    }\n  }\n\n  const flush = (serviceIdentifier?: interfaces.ServiceIdentifier<any>) => {\n    if (serviceIdentifier) {\n      cache.delete(serviceIdentifier)\n    } else {\n      cache.clear()\n    }\n  }\n\n  return { middleware, flush }\n}\n"]}