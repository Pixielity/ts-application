{"version":3,"sources":["../../src/config/validator.ts"],"names":[],"mappings":"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","file":"validator.mjs","sourcesContent":["import type { IConfigValidator, IConfigSchema } from '@pixielity/ts-types'\n\n/**\n * Configuration validation error\n */\nexport class ConfigValidationError extends Error {\n  /**\n   * The validation errors\n   */\n  public errors: string[]\n\n  /**\n   * Create a new configuration validation error\n   *\n   * @param message - The error message\n   * @param errors - The validation errors\n   */\n  constructor(message: string, errors: string[] = []) {\n    super(message)\n    this.name = 'ConfigValidationError'\n    this.errors = errors\n  }\n\n  /**\n   * Create a new configuration validation error\n   *\n   * @param message - The error message\n   * @param errors - The validation errors\n   * @returns A new configuration validation error\n   */\n  public static make(message: string, errors: string[] = []): ConfigValidationError {\n    return new ConfigValidationError(message, errors)\n  }\n}\n\n/**\n * Configuration validator with schema auto-detection\n */\nexport class ConfigValidator implements IConfigValidator {\n  /**\n   * The configuration schemas\n   */\n  private schemas: Record<string, IConfigSchema> = {}\n\n  /**\n   * Whether to auto-detect schemas from $schema properties\n   */\n  private autoDetectSchemas = true\n\n  /**\n   * Create a new configuration validator\n   *\n   * @param schemas - The configuration schemas\n   * @param autoDetectSchemas - Whether to auto-detect schemas from $schema properties\n   */\n  constructor(schemas: Record<string, IConfigSchema> = {}, autoDetectSchemas = true) {\n    this.schemas = schemas\n    this.autoDetectSchemas = autoDetectSchemas\n  }\n\n  /**\n   * Create a new configuration validator\n   *\n   * @param schemas - The configuration schemas\n   * @param autoDetectSchemas - Whether to auto-detect schemas from $schema properties\n   * @returns A new configuration validator\n   */\n  public static make(\n    schemas: Record<string, IConfigSchema> = {},\n    autoDetectSchemas = true,\n  ): ConfigValidator {\n    return new ConfigValidator(schemas, autoDetectSchemas)\n  }\n\n  /**\n   * Set the configuration schemas\n   *\n   * @param schemas - The configuration schemas\n   */\n  public setSchemas(schemas: Record<string, IConfigSchema>): void {\n    this.schemas = schemas\n  }\n\n  /**\n   * Add a configuration schema\n   *\n   * @param key - The schema key\n   * @param schema - The schema\n   */\n  public addSchema(key: string, schema: IConfigSchema): void {\n    this.schemas[key] = schema\n  }\n\n  /**\n   * Enable or disable schema auto-detection\n   *\n   * @param enable - Whether to enable schema auto-detection\n   */\n  public setAutoDetectSchemas(enable: boolean): void {\n    this.autoDetectSchemas = enable\n  }\n\n  /**\n   * Validate a configuration value against its schema\n   *\n   * @param key - The configuration key\n   * @param value - The configuration value\n   * @returns Whether the value is valid\n   * @throws ConfigValidationError if validation fails\n   */\n  public validate(key: string, value: any): boolean {\n    // Check for auto-detected schema in the value itself\n    let schema = this.schemas[key]\n\n    if (this.autoDetectSchemas && value && typeof value === 'object' && value.$schema) {\n      // If the value has a $schema property, use it for validation\n      try {\n        // The $schema could be a direct schema object or a reference to a schema\n        if (typeof value.$schema === 'string') {\n          // If it's a string, check if we have this schema registered\n          if (this.schemas[value.$schema]) {\n            schema = this.schemas[value.$schema]\n          } else {\n            console.warn(`Schema reference '${value.$schema}' not found in registered schemas`)\n          }\n        } else if (typeof value.$schema === 'object') {\n          // If it's an object, use it directly as the schema\n          schema = value.$schema\n        }\n      } catch (error) {\n        console.warn(`Error processing $schema property: ${error}`)\n      }\n    }\n\n    if (!schema) {\n      // No schema defined for this key, so validation passes\n      return true\n    }\n\n    const errors = this.validateAgainstSchema(value, schema, key)\n    if (errors.length > 0) {\n      throw ConfigValidationError.make(`Configuration validation failed for '${key}'`, errors)\n    }\n\n    return true\n  }\n\n  /**\n   * Validate a value against a schema\n   *\n   * @param value - The value to validate\n   * @param schema - The schema to validate against\n   * @param path - The current path (for error messages)\n   * @returns An array of validation errors\n   * @private\n   */\n  private validateAgainstSchema(value: any, schema: IConfigSchema, path: string): string[] {\n    const errors: string[] = []\n\n    // Skip validation for the $schema property itself\n    if (path.endsWith('.$schema')) {\n      return errors\n    }\n\n    // Check type\n    if (schema.type && !this.checkType(value, schema.type)) {\n      errors.push(`${path}: Expected type '${schema.type}', got '${typeof value}'`)\n    }\n\n    // Check required\n    if (schema.required && (value === undefined || value === null)) {\n      errors.push(`${path}: Required value is missing`)\n    }\n\n    // Check enum\n    if (schema.enum && !schema.enum.includes(value)) {\n      errors.push(`${path}: Value must be one of [${schema.enum.join(', ')}]`)\n    }\n\n    // Check min/max for numbers\n    if (schema.type === 'number' || schema.type === 'integer') {\n      if (schema.minimum !== undefined && value < schema.minimum) {\n        errors.push(`${path}: Value must be >= ${schema.minimum}`)\n      }\n      if (schema.maximum !== undefined && value > schema.maximum) {\n        errors.push(`${path}: Value must be <= ${schema.maximum}`)\n      }\n    }\n\n    // Check minLength/maxLength for strings\n    if (schema.type === 'string') {\n      if (schema.minLength !== undefined && value.length < schema.minLength) {\n        errors.push(`${path}: String length must be >= ${schema.minLength}`)\n      }\n      if (schema.maxLength !== undefined && value.length > schema.maxLength) {\n        errors.push(`${path}: String length must be <= ${schema.maxLength}`)\n      }\n      if (schema.pattern && !new RegExp(schema.pattern).test(value)) {\n        errors.push(`${path}: String must match pattern '${schema.pattern}'`)\n      }\n    }\n\n    // Check properties for objects\n    if (schema.type === 'object' && schema.properties) {\n      Object.entries(schema.properties).forEach(([propName, propSchema]) => {\n        // Skip validation for the $schema property\n        if (propName === '$schema') {\n          return\n        }\n\n        const propPath = `${path}.${propName}`\n        const propValue = value?.[propName]\n\n        // Check if property is required\n        if (propSchema.required && (propValue === undefined || propValue === null)) {\n          errors.push(`${propPath}: Required property is missing`)\n        }\n\n        // Validate property if it exists\n        if (propValue !== undefined && propValue !== null) {\n          errors.push(...this.validateAgainstSchema(propValue, propSchema, propPath))\n        }\n      })\n    }\n\n    // Check items for arrays\n    if (schema.type === 'array' && schema.items && Array.isArray(value)) {\n      value.forEach((item, index) => {\n        const itemPath = `${path}[${index}]`\n        errors.push(...this.validateAgainstSchema(item, schema.items!, itemPath))\n      })\n    }\n\n    return errors\n  }\n\n  /**\n   * Check if a value matches a type\n   *\n   * @param value - The value to check\n   * @param type - The expected type\n   * @returns Whether the value matches the type\n   * @private\n   */\n  private checkType(value: any, type: string): boolean {\n    switch (type) {\n      case 'string':\n        return typeof value === 'string'\n      case 'number':\n        return typeof value === 'number' && !isNaN(value)\n      case 'integer':\n        return typeof value === 'number' && !isNaN(value) && Number.isInteger(value)\n      case 'boolean':\n        return typeof value === 'boolean'\n      case 'array':\n        return Array.isArray(value)\n      case 'object':\n        return typeof value === 'object' && value !== null && !Array.isArray(value)\n      case 'null':\n        return value === null\n      default:\n        return true\n    }\n  }\n}\n"]}