{"version":3,"sources":["../../../src/decorators/abstract-decorator.ts","../../../src/config/decorators/env-config.decorator.ts"],"names":[],"mappings":";;;AA2JO,SAAS,wBACd,SACmB,EAAA;AACnB,EAAO,OAAA,CAAC,QAAa,WAAiC,KAAA;AAEpD,IAAA,SAAA,CAAU,QAAQ,WAAW,CAAA;AAAA,GAC/B;AACF;;;AC1IO,SAAS,UAAU,OAAyB,EAAA;AACjD,EAAO,OAAA,uBAAA,CAAwB,CAAC,MAAA,EAAa,WAAiC,KAAA;AAE5E,IAAO,MAAA,CAAA,cAAA,CAAe,QAAQ,WAAa,EAAA;AAAA,MACzC,KAAK,MAAM;AAET,QAAA,MAAM,QAAQ,OAAQ,CAAA,GAAA,GAAM,QAAQ,GAAI,CAAA,OAAA,CAAQ,GAAG,CAAI,GAAA,MAAA;AAEvD,QAAA,IAAI,UAAU,MAAW,EAAA;AACvB,UAAA,OAAO,OAAQ,CAAA,YAAA;AAAA;AAIjB,QAAI,IAAA,WAAA;AAEJ,QAAA,IAAI,KAAM,CAAA,WAAA,EAAkB,KAAA,MAAA,EAAsB,WAAA,GAAA,IAAA;AAAA,aAAA,IACzC,KAAM,CAAA,WAAA,EAAkB,KAAA,OAAA,EAAuB,WAAA,GAAA,KAAA;AAAA,aAC/C,IAAA,SAAA,CAAU,KAAK,KAAK,CAAA,gBAAiB,MAAO,CAAA,QAAA,CAAS,OAAO,EAAE,CAAA;AAAA,aAAA,IAC9D,eAAe,IAAK,CAAA,KAAK,GAAiB,WAAA,GAAA,MAAA,CAAO,WAAW,KAAK,CAAA;AAAA,aACvD,WAAA,GAAA,KAAA;AAGnB,QAAA,IAAI,QAAQ,SAAW,EAAA;AACrB,UAAc,WAAA,GAAA,OAAA,CAAQ,UAAU,WAAW,CAAA;AAAA;AAG7C,QAAO,OAAA,WAAA;AAAA,OACT;AAAA,MACA,UAAY,EAAA,IAAA;AAAA,MACZ,YAAc,EAAA;AAAA,KACf,CAAA;AAAA,GACF,CAAA;AACH","file":"env-config.decorator.mjs","sourcesContent":["import 'reflect-metadata'\nimport type { IClassDecoratorOptions } from '@pixielity/ts-types'\n\n/**\n * Create a class decorator that preserves Inversify metadata\n *\n * @param decorator - The decorator function to apply\n * @param options - Options for the decorator\n * @returns A class decorator function\n *\n * @example\n * ```typescript\n * // Create a simple logging decorator\n * export function LogClass() {\n *   return createClassDecorator((target) => {\n *     console.log(`Class ${target.name} was decorated`);\n *     return target;\n *   });\n * }\n *\n * // Create a decorator with options\n * export function Singleton() {\n *   return createClassDecorator((target) => target, {\n *     beforeConstructor: (target) => {\n *       console.log(`Creating singleton instance of ${target.name}`);\n *     }\n *   });\n * }\n * ```\n */\nexport function createClassDecorator(\n  decorator: (target: any) => any,\n  options: IClassDecoratorOptions = {},\n): ClassDecorator {\n  const {\n    copyPrototype = true,\n    copyStatic = true,\n    copyMetadata = true,\n    beforeConstructor,\n    afterConstructor,\n    transformInstance,\n  } = options\n\n  return (target: any) => {\n    // Apply the decorator to get the modified target\n    const decoratedTarget = decorator(target)\n\n    // If the decorator returns undefined or the same target, no need for the proxy\n    if (decoratedTarget === undefined || decoratedTarget === target) {\n      return target\n    }\n\n    // A utility function to generate instances of a class\n    function construct(constructor: any, args: any[]) {\n      // Run before constructor hook if provided\n      if (beforeConstructor) {\n        beforeConstructor(constructor, args)\n      }\n\n      // Create the instance\n      const instance = new constructor(...args)\n\n      // Run after constructor hook if provided\n      if (afterConstructor) {\n        afterConstructor(instance, constructor, args)\n      }\n\n      // Transform the instance if needed\n      return transformInstance ? transformInstance(instance, constructor, args) : instance\n    }\n\n    // The new constructor behavior\n    const newConstructor: any = (...args: any[]) => construct(decoratedTarget, args)\n\n    // Copy prototype so instanceof operator still works\n    if (copyPrototype) {\n      newConstructor.prototype = decoratedTarget.prototype\n    }\n\n    // Copy static properties\n    if (copyStatic) {\n      Object.getOwnPropertyNames(decoratedTarget).forEach((prop) => {\n        if (prop !== 'prototype' && prop !== 'name' && prop !== 'length') {\n          const descriptor = Object.getOwnPropertyDescriptor(decoratedTarget, prop)\n          if (descriptor) {\n            Object.defineProperty(newConstructor, prop, descriptor)\n          }\n        }\n      })\n    }\n\n    // Copy metadata\n    if (copyMetadata) {\n      const metadataKeys = Reflect.getMetadataKeys(target)\n      metadataKeys.forEach((metadataKey) => {\n        const metadataValue = Reflect.getMetadata(metadataKey, target)\n        Reflect.defineMetadata(metadataKey, metadataValue, newConstructor)\n      })\n    }\n\n    // Return new constructor (will override original)\n    return newConstructor\n  }\n}\n\n/**\n * Create a method decorator\n *\n * @param decorator - The decorator function to apply\n * @returns A method decorator function\n *\n * @example\n * ```typescript\n * // Create a simple logging decorator\n * export function LogMethod() {\n *   return createMethodDecorator((target, propertyKey, descriptor) => {\n *     const original = descriptor.value;\n *     descriptor.value = function(...args: any[]) {\n *       console.log(`Method ${String(propertyKey)} was called with args:`, args);\n *       return original.apply(this, args);\n *     };\n *     return descriptor;\n *   });\n * }\n * ```\n */\nexport function createMethodDecorator(\n  decorator: (\n    target: any,\n    propertyKey: string | symbol,\n    descriptor: PropertyDescriptor,\n  ) => PropertyDescriptor,\n): MethodDecorator {\n  return (target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor) => {\n    // Apply the decorator\n    return decorator(target, propertyKey, descriptor)\n  }\n}\n\n/**\n * Create a property decorator\n *\n * @param decorator - The decorator function to apply\n * @returns A property decorator function\n *\n * @example\n * ```typescript\n * // Create a simple logging decorator\n * export function LogProperty() {\n *   return createPropertyDecorator((target, propertyKey) => {\n *     console.log(`Property ${String(propertyKey)} was decorated`);\n *   });\n * }\n * ```\n */\nexport function createPropertyDecorator(\n  decorator: (target: any, propertyKey: string | symbol) => void,\n): PropertyDecorator {\n  return (target: any, propertyKey: string | symbol) => {\n    // Apply the decorator\n    decorator(target, propertyKey)\n  }\n}\n\n/**\n * Create a parameter decorator\n *\n * @param decorator - The decorator function to apply\n * @returns A parameter decorator function\n *\n * @example\n * ```typescript\n * // Create a simple logging decorator\n * export function LogParameter() {\n *   return createParameterDecorator((target, propertyKey, parameterIndex) => {\n *     console.log(`Parameter ${parameterIndex} of ${String(propertyKey)} was decorated`);\n *   });\n * }\n * ```\n */\nexport function createParameterDecorator(\n  decorator: (\n    target: any,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ) => void,\n): ParameterDecorator {\n  return (target: any, propertyKey: string | symbol | undefined, parameterIndex: number) => {\n    // Apply the decorator\n    decorator(target, propertyKey, parameterIndex)\n  }\n}\n\n/**\n * Abstract decorator base class that can be extended to create custom decorators\n */\nexport abstract class AbstractDecorator {\n  /**\n   * Create a class decorator\n   *\n   * @param options - Options for the decorator\n   * @returns A class decorator function\n   */\n  protected createClassDecorator(options: IClassDecoratorOptions = {}): ClassDecorator {\n    return createClassDecorator((target) => this.decorateClass(target), options)\n  }\n\n  /**\n   * Create a method decorator\n   *\n   * @returns A method decorator function\n   */\n  protected createMethodDecorator(): MethodDecorator {\n    return createMethodDecorator((target, propertyKey, descriptor) =>\n      this.decorateMethod(target, propertyKey, descriptor),\n    )\n  }\n\n  /**\n   * Create a property decorator\n   *\n   * @returns A property decorator function\n   */\n  protected createPropertyDecorator(): PropertyDecorator {\n    return createPropertyDecorator((target, propertyKey) =>\n      this.decorateProperty(target, propertyKey),\n    )\n  }\n\n  /**\n   * Create a parameter decorator\n   *\n   * @returns A parameter decorator function\n   */\n  protected createParameterDecorator(): ParameterDecorator {\n    return createParameterDecorator((target, propertyKey, parameterIndex) =>\n      this.decorateParameter(target, propertyKey, parameterIndex),\n    )\n  }\n\n  /**\n   * Decorate a class\n   *\n   * @param target - The class to decorate\n   * @returns The decorated class\n   */\n  protected abstract decorateClass(target: any): any\n\n  /**\n   * Decorate a method\n   *\n   * @param target - The target object\n   * @param propertyKey - The method name\n   * @param descriptor - The method descriptor\n   * @returns The decorated method descriptor\n   */\n  protected decorateMethod(\n    target: any,\n    propertyKey: string | symbol,\n    descriptor: PropertyDescriptor,\n  ): PropertyDescriptor {\n    return descriptor\n  }\n\n  /**\n   * Decorate a property\n   *\n   * @param target - The target object\n   * @param propertyKey - The property name\n   */\n  protected decorateProperty(target: any, propertyKey: string | symbol): void {\n    // Default implementation does nothing\n  }\n\n  /**\n   * Decorate a parameter\n   *\n   * @param target - The target object\n   * @param propertyKey - The method name\n   * @param parameterIndex - The parameter index\n   */\n  protected decorateParameter(\n    target: any,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ): void {\n    // Default implementation does nothing\n  }\n\n  /**\n   * Create a new abstract decorator\n   *\n   * @returns A new abstract decorator\n   */\n  public static make(): AbstractDecorator {\n    throw new Error('Cannot instantiate abstract class')\n  }\n}\n","import { createPropertyDecorator } from '../../decorators/abstract-decorator'\nimport { IConfigOptions } from '@pixielity/ts-types'\n\n/**\n * Get an environment variable and inject it into a class property.\n *\n * @param options - The environment configuration options\n * @returns A property decorator\n *\n * @example\n * ```typescript\n * class AppService {\n *   @EnvConfig({ env: 'APP_NAME', defaultValue: 'My App' })\n *   private appName: string;\n *\n *   @EnvConfig({ env: 'APP_DEBUG' })\n *   private debug: boolean;\n *\n *   public getAppName(): string {\n *     return this.appName;\n *   }\n * }\n * ```\n */\nexport function EnvConfig(options: IConfigOptions) {\n  return createPropertyDecorator((target: any, propertyKey: string | symbol) => {\n    // Define a getter for the property\n    Object.defineProperty(target, propertyKey, {\n      get: () => {\n        // Get the environment variable\n        const value = options.env ? process.env[options.env] : undefined\n\n        if (value === undefined) {\n          return options.defaultValue\n        }\n\n        // Parse the value\n        let parsedValue: any\n\n        if (value.toLowerCase() === 'true') parsedValue = true\n        else if (value.toLowerCase() === 'false') parsedValue = false\n        else if (/^-?\\d+$/.test(value)) parsedValue = Number.parseInt(value, 10)\n        else if (/^-?\\d+\\.\\d+$/.test(value)) parsedValue = Number.parseFloat(value)\n        else parsedValue = value\n\n        // Apply transform function if provided\n        if (options.transform) {\n          parsedValue = options.transform(parsedValue)\n        }\n\n        return parsedValue\n      },\n      enumerable: true,\n      configurable: true,\n    })\n  })\n}\n"]}