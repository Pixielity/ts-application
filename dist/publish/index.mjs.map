{"version":3,"sources":["../../../../../node_modules/inversify/es/constants/metadata_keys.js","../../../../../node_modules/inversify/es/constants/error_msgs.js","../../../../../node_modules/inversify/es/annotation/injectable.js","../../src/publish/publisher.ts","../../src/service-provider.ts","../../src/publish/publisher.interface.ts","../../src/publish/publish-service-provider.ts"],"names":["IPublisher"],"mappings":"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","file":"index.mjs","sourcesContent":["export var NAMED_TAG = 'named';\r\nexport var NAME_TAG = 'name';\r\nexport var UNMANAGED_TAG = 'unmanaged';\r\nexport var OPTIONAL_TAG = 'optional';\r\nexport var INJECT_TAG = 'inject';\r\nexport var MULTI_INJECT_TAG = 'multi_inject';\r\nexport var TAGGED = 'inversify:tagged';\r\nexport var TAGGED_PROP = 'inversify:tagged_props';\r\nexport var PARAM_TYPES = 'inversify:paramtypes';\r\nexport var DESIGN_PARAM_TYPES = 'design:paramtypes';\r\nexport var POST_CONSTRUCT = 'post_construct';\r\nexport var PRE_DESTROY = 'pre_destroy';\r\nfunction getNonCustomTagKeys() {\r\n    return [\r\n        INJECT_TAG,\r\n        MULTI_INJECT_TAG,\r\n        NAME_TAG,\r\n        UNMANAGED_TAG,\r\n        NAMED_TAG,\r\n        OPTIONAL_TAG,\r\n    ];\r\n}\r\nexport var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();\r\n","export var DUPLICATED_INJECTABLE_DECORATOR = 'Cannot apply @injectable decorator multiple times.';\r\nexport var DUPLICATED_METADATA = 'Metadata key was used more than once in a parameter:';\r\nexport var NULL_ARGUMENT = 'NULL argument';\r\nexport var KEY_NOT_FOUND = 'Key Not Found';\r\nexport var AMBIGUOUS_MATCH = 'Ambiguous match found for serviceIdentifier:';\r\nexport var CANNOT_UNBIND = 'Could not unbind serviceIdentifier:';\r\nexport var NOT_REGISTERED = 'No matching bindings found for serviceIdentifier:';\r\nexport var MISSING_INJECTABLE_ANNOTATION = 'Missing required @injectable annotation in:';\r\nexport var MISSING_INJECT_ANNOTATION = 'Missing required @inject or @multiInject annotation in:';\r\nexport var UNDEFINED_INJECT_ANNOTATION = function (name) {\r\n    return \"@inject called with undefined this could mean that the class \" + name + \" has \" +\r\n        'a circular dependency problem. You can use a LazyServiceIdentifier to  ' +\r\n        'overcome this limitation.';\r\n};\r\nexport var CIRCULAR_DEPENDENCY = 'Circular dependency found:';\r\nexport var NOT_IMPLEMENTED = 'Sorry, this feature is not fully implemented yet.';\r\nexport var INVALID_BINDING_TYPE = 'Invalid binding type:';\r\nexport var NO_MORE_SNAPSHOTS_AVAILABLE = 'No snapshot available to restore.';\r\nexport var INVALID_MIDDLEWARE_RETURN = 'Invalid return type in middleware. Middleware must return!';\r\nexport var INVALID_FUNCTION_BINDING = 'Value provided to function binding must be a function!';\r\nexport var LAZY_IN_SYNC = function (key) { return \"You are attempting to construct '\" + key + \"' in a synchronous way\\n but it has asynchronous dependencies.\"; };\r\nexport var INVALID_TO_SELF_VALUE = 'The toSelf function can only be applied when a constructor is ' +\r\n    'used as service identifier';\r\nexport var INVALID_DECORATOR_OPERATION = 'The @inject @multiInject @tagged and @named decorators ' +\r\n    'must be applied to the parameters of a class constructor or a class property.';\r\nexport var ARGUMENTS_LENGTH_MISMATCH = function () {\r\n    var values = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        values[_i] = arguments[_i];\r\n    }\r\n    return 'The number of constructor arguments in the derived class ' +\r\n        (values[0] + \" must be >= than the number of constructor arguments of its base class.\");\r\n};\r\nexport var CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = 'Invalid Container constructor argument. Container options ' +\r\n    'must be an object.';\r\nexport var CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must ' +\r\n    'be a string (\"singleton\" or \"transient\").';\r\nexport var CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = 'Invalid Container option. Auto bind injectable must ' +\r\n    'be a boolean';\r\nexport var CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = 'Invalid Container option. Skip base check must ' +\r\n    'be a boolean';\r\nexport var MULTIPLE_PRE_DESTROY_METHODS = 'Cannot apply @preDestroy decorator multiple times in the same class';\r\nexport var MULTIPLE_POST_CONSTRUCT_METHODS = 'Cannot apply @postConstruct decorator multiple times in the same class';\r\nexport var ASYNC_UNBIND_REQUIRED = 'Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)';\r\nexport var POST_CONSTRUCT_ERROR = function (clazz, errorMessage) { return \"@postConstruct error in class \" + clazz + \": \" + errorMessage; };\r\nexport var PRE_DESTROY_ERROR = function (clazz, errorMessage) { return \"@preDestroy error in class \" + clazz + \": \" + errorMessage; };\r\nexport var ON_DEACTIVATION_ERROR = function (clazz, errorMessage) { return \"onDeactivation() error in class \" + clazz + \": \" + errorMessage; };\r\nexport var CIRCULAR_DEPENDENCY_IN_FACTORY = function (factoryType, serviceIdentifier) {\r\n    return \"It looks like there is a circular dependency in one of the '\" + factoryType + \"' bindings. Please investigate bindings with \" +\r\n        (\"service identifier '\" + serviceIdentifier + \"'.\");\r\n};\r\nexport var STACK_OVERFLOW = 'Maximum call stack size exceeded';\r\n","import * as ERRORS_MSGS from '../constants/error_msgs';\r\nimport * as METADATA_KEY from '../constants/metadata_keys';\r\nfunction injectable() {\r\n    return function (target) {\r\n        if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {\r\n            throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);\r\n        }\r\n        var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];\r\n        Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);\r\n        return target;\r\n    };\r\n}\r\nexport { injectable };\r\n","import { injectable } from 'inversify'\nimport * as fs from 'fs'\nimport * as path from 'path'\nimport { IPublisher, IPublisherOptions } from './publisher.interface'\n\n/**\n * Publisher for publishing assets, views, and translations\n */\n@injectable()\nexport class Publisher implements IPublisher {\n  /**\n   * The registered publishers\n   */\n  private publishers: Map<\n    string,\n    (source: string, target: string, options: IPublisherOptions) => Promise<boolean>\n  > = new Map()\n\n  /**\n   * Create a new publisher\n   */\n  constructor() {\n    // Register default publishers\n    this.registerDefaultPublishers()\n  }\n\n  /**\n   * Create a new publisher\n   *\n   * @returns A new publisher\n   */\n  public static make(): IPublisher {\n    return new Publisher()\n  }\n\n  /**\n   * Register default publishers\n   * @private\n   */\n  private registerDefaultPublishers(): void {\n    // Register asset publisher\n    this.register('assets', this.publishAssets.bind(this))\n\n    // Register views publisher\n    this.register('views', this.publishViews.bind(this))\n\n    // Register translations publisher\n    this.register('translations', this.publishTranslations.bind(this))\n\n    // Register config publisher\n    this.register('config', this.publishConfig.bind(this))\n  }\n\n  /**\n   * Register a publisher\n   *\n   * @param name - The publisher name\n   * @param publisher - The publisher function\n   * @returns The publisher instance\n   */\n  public register(\n    name: string,\n    publisher: (source: string, target: string, options: IPublisherOptions) => Promise<boolean>,\n  ): IPublisher {\n    this.publishers.set(name, publisher)\n    return this\n  }\n\n  /**\n   * Publish assets\n   *\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   * @returns Whether the publishing was successful\n   */\n  public async publishAssets(\n    source: string,\n    target: string,\n    options: IPublisherOptions = {},\n  ): Promise<boolean> {\n    return this.publishDirectory(source, target, options)\n  }\n\n  /**\n   * Publish views\n   *\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   * @returns Whether the publishing was successful\n   */\n  public async publishViews(\n    source: string,\n    target: string,\n    options: IPublisherOptions = {},\n  ): Promise<boolean> {\n    return this.publishDirectory(source, target, options)\n  }\n\n  /**\n   * Publish translations\n   *\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   * @returns Whether the publishing was successful\n   */\n  public async publishTranslations(\n    source: string,\n    target: string,\n    options: IPublisherOptions = {},\n  ): Promise<boolean> {\n    return this.publishDirectory(source, target, options)\n  }\n\n  /**\n   * Publish configuration\n   *\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   * @returns Whether the publishing was successful\n   */\n  public async publishConfig(\n    source: string,\n    target: string,\n    options: IPublisherOptions = {},\n  ): Promise<boolean> {\n    return this.publishDirectory(source, target, options)\n  }\n\n  /**\n   * Publish a directory\n   *\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   * @returns Whether the publishing was successful\n   * @private\n   */\n  private async publishDirectory(\n    source: string,\n    target: string,\n    options: IPublisherOptions = {},\n  ): Promise<boolean> {\n    try {\n      // Create the target directory if it doesn't exist\n      if (!fs.existsSync(target)) {\n        fs.mkdirSync(target, { recursive: true })\n      }\n\n      // Get all files in the source directory\n      const files = this.getFiles(source)\n\n      // Publish each file\n      for (const file of files) {\n        const relativePath = path.relative(source, file)\n        const targetPath = path.join(target, relativePath)\n\n        // Create the target directory if it doesn't exist\n        const targetDir = path.dirname(targetPath)\n        if (!fs.existsSync(targetDir)) {\n          fs.mkdirSync(targetDir, { recursive: true })\n        }\n\n        // Skip if the file exists and force is not enabled\n        if (fs.existsSync(targetPath) && !options.force) {\n          console.log(`Skipping ${targetPath} (already exists)`)\n          continue\n        }\n\n        // Copy the file\n        fs.copyFileSync(file, targetPath)\n        console.log(`Published ${targetPath}`)\n      }\n\n      return true\n    } catch (error) {\n      console.error(`Error publishing directory ${source} to ${target}:`, error)\n      return false\n    }\n  }\n\n  /**\n   * Get all files in a directory recursively\n   *\n   * @param directory - The directory to get files from\n   * @returns The files in the directory\n   * @private\n   */\n  private getFiles(directory: string): string[] {\n    const files: string[] = []\n\n    // Get all entries in the directory\n    const entries = fs.readdirSync(directory, { withFileTypes: true })\n\n    // Process each entry\n    for (const entry of entries) {\n      const fullPath = path.join(directory, entry.name)\n\n      if (entry.isDirectory()) {\n        // Recursively get files from subdirectories\n        files.push(...this.getFiles(fullPath))\n      } else {\n        // Add the file\n        files.push(fullPath)\n      }\n    }\n\n    return files\n  }\n\n  /**\n   * Publish using a registered publisher\n   *\n   * @param name - The publisher name\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   * @returns Whether the publishing was successful\n   */\n  public async publish(\n    name: string,\n    source: string,\n    target: string,\n    options: IPublisherOptions = {},\n  ): Promise<boolean> {\n    const publisher = this.publishers.get(name)\n\n    if (!publisher) {\n      throw new Error(`Publisher \"${name}\" not found`)\n    }\n\n    return publisher(source, target, options)\n  }\n}\n","import type { IContainer } from '@pixielity/ts-types'\n\n/**\n * Base service provider class that all service providers must extend.\n * Service providers are responsible for binding services into the container\n * and bootstrapping any dependencies.\n *\n * @example\n * ```ts\n * class CacheServiceProvider extends ServiceProvider {\n *   register(): void {\n *     this.app.singleton('cache', () => new ICache(this.app))\n *   }\n * }\n * const provider = CacheServiceProvider.make(app)\n * ```\n */\nexport abstract class ServiceProvider {\n  /**\n   * The application container instance.\n   */\n  public app: IContainer\n\n  /**\n   * Create a new service provider instance.\n   *\n   * @param app - The application container instance\n   */\n  constructor(app: IContainer) {\n    this.app = app\n  }\n\n  /**\n   * Static factory method to create a new instance of the service provider.\n   *\n   * @param app - The application container instance\n   * @param args - Additional arguments to be passed to the subclass constructor\n   * @returns A new instance of the subclass\n   */\n  static make<T extends typeof ServiceProvider>(\n    this: T,\n    app: IContainer,\n    ...args: ConstructorParameters<T>\n  ): InstanceType<T> {\n    if (this === ServiceProvider) {\n      throw new Error('Cannot instantiate an abstract class directly.')\n    }\n    return new (this as any)(app, ...args) as InstanceType<T>\n  }\n\n  /**\n   * Register any application services.\n   * This method is called when the service provider is registered with the container.\n   */\n  abstract register(): void\n\n  /**\n   * Bootstrap any application services.\n   * This method is called after all service providers have been registered.\n   */\n  boot?(): void\n\n  /**\n   * Gracefully terminate services (e.g., close DB, clear jobs).\n   * Called during app shutdown, if implemented.\n   */\n  terminate?(): void\n\n  /**\n   * Publish assets, configs, or resources, if applicable.\n   * Typically used for copying files to the consumer project.\n   */\n  publish?(): void\n}\n","/**\n * IPublisher options\n */\nexport interface IPublisherOptions {\n  /**\n   * Whether to force overwrite existing files\n   */\n  force?: boolean\n}\n\n/**\n * Interface for the Publisher service.\n */\nexport interface IPublisher {\n  /**\n   * Register a publisher function under a given name.\n   *\n   * @param name - The publisher name\n   * @param publisher - The publishing function\n   */\n  register(\n    name: string,\n    publisher: (source: string, target: string, options: IPublisherOptions) => Promise<boolean>,\n  ): IPublisher\n\n  /**\n   * Publish using a registered publisher.\n   *\n   * @param name - The publisher name\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   */\n  publish(\n    name: string,\n    source: string,\n    target: string,\n    options?: IPublisherOptions,\n  ): Promise<boolean>\n\n  /**\n   * Publish assets.\n   */\n  publishAssets(source: string, target: string, options?: IPublisherOptions): Promise<boolean>\n\n  /**\n   * Publish views.\n   */\n  publishViews(source: string, target: string, options?: IPublisherOptions): Promise<boolean>\n\n  /**\n   * Publish translations.\n   */\n  publishTranslations(source: string, target: string, options?: IPublisherOptions): Promise<boolean>\n\n  /**\n   * Publish configuration files.\n   */\n  publishConfig(source: string, target: string, options?: IPublisherOptions): Promise<boolean>\n}\n\n/**\n * IApplication options\n */\nexport namespace IPublisher {\n  export const $ = Symbol.for('IPublisher')\n}\n","import { ServiceProvider } from '../service-provider'\nimport { Publisher } from './publisher'\nimport { IPublisher } from './publisher.interface'\n\n/**\n * Publish service provider\n */\nexport class PublishServiceProvider extends ServiceProvider {\n  /**\n   * Register the service provider\n   */\n  public register(): void {\n    this.app.singleton(IPublisher.$, () => {\n      return Publisher.make()\n    })\n  }\n\n  /**\n   * Bootstrap the service provider\n   */\n  public boot(): void {\n    // No boot actions needed\n  }\n}\n"]}