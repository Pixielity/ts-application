{"version":3,"sources":["../../../../../node_modules/inversify/es/constants/metadata_keys.js","../../../../../node_modules/inversify/es/constants/error_msgs.js","../../../../../node_modules/inversify/es/annotation/injectable.js","../../src/publish/publisher.ts"],"names":[],"mappings":"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","file":"publisher.mjs","sourcesContent":["export var NAMED_TAG = 'named';\r\nexport var NAME_TAG = 'name';\r\nexport var UNMANAGED_TAG = 'unmanaged';\r\nexport var OPTIONAL_TAG = 'optional';\r\nexport var INJECT_TAG = 'inject';\r\nexport var MULTI_INJECT_TAG = 'multi_inject';\r\nexport var TAGGED = 'inversify:tagged';\r\nexport var TAGGED_PROP = 'inversify:tagged_props';\r\nexport var PARAM_TYPES = 'inversify:paramtypes';\r\nexport var DESIGN_PARAM_TYPES = 'design:paramtypes';\r\nexport var POST_CONSTRUCT = 'post_construct';\r\nexport var PRE_DESTROY = 'pre_destroy';\r\nfunction getNonCustomTagKeys() {\r\n    return [\r\n        INJECT_TAG,\r\n        MULTI_INJECT_TAG,\r\n        NAME_TAG,\r\n        UNMANAGED_TAG,\r\n        NAMED_TAG,\r\n        OPTIONAL_TAG,\r\n    ];\r\n}\r\nexport var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();\r\n","export var DUPLICATED_INJECTABLE_DECORATOR = 'Cannot apply @injectable decorator multiple times.';\r\nexport var DUPLICATED_METADATA = 'Metadata key was used more than once in a parameter:';\r\nexport var NULL_ARGUMENT = 'NULL argument';\r\nexport var KEY_NOT_FOUND = 'Key Not Found';\r\nexport var AMBIGUOUS_MATCH = 'Ambiguous match found for serviceIdentifier:';\r\nexport var CANNOT_UNBIND = 'Could not unbind serviceIdentifier:';\r\nexport var NOT_REGISTERED = 'No matching bindings found for serviceIdentifier:';\r\nexport var MISSING_INJECTABLE_ANNOTATION = 'Missing required @injectable annotation in:';\r\nexport var MISSING_INJECT_ANNOTATION = 'Missing required @inject or @multiInject annotation in:';\r\nexport var UNDEFINED_INJECT_ANNOTATION = function (name) {\r\n    return \"@inject called with undefined this could mean that the class \" + name + \" has \" +\r\n        'a circular dependency problem. You can use a LazyServiceIdentifier to  ' +\r\n        'overcome this limitation.';\r\n};\r\nexport var CIRCULAR_DEPENDENCY = 'Circular dependency found:';\r\nexport var NOT_IMPLEMENTED = 'Sorry, this feature is not fully implemented yet.';\r\nexport var INVALID_BINDING_TYPE = 'Invalid binding type:';\r\nexport var NO_MORE_SNAPSHOTS_AVAILABLE = 'No snapshot available to restore.';\r\nexport var INVALID_MIDDLEWARE_RETURN = 'Invalid return type in middleware. Middleware must return!';\r\nexport var INVALID_FUNCTION_BINDING = 'Value provided to function binding must be a function!';\r\nexport var LAZY_IN_SYNC = function (key) { return \"You are attempting to construct '\" + key + \"' in a synchronous way\\n but it has asynchronous dependencies.\"; };\r\nexport var INVALID_TO_SELF_VALUE = 'The toSelf function can only be applied when a constructor is ' +\r\n    'used as service identifier';\r\nexport var INVALID_DECORATOR_OPERATION = 'The @inject @multiInject @tagged and @named decorators ' +\r\n    'must be applied to the parameters of a class constructor or a class property.';\r\nexport var ARGUMENTS_LENGTH_MISMATCH = function () {\r\n    var values = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        values[_i] = arguments[_i];\r\n    }\r\n    return 'The number of constructor arguments in the derived class ' +\r\n        (values[0] + \" must be >= than the number of constructor arguments of its base class.\");\r\n};\r\nexport var CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = 'Invalid Container constructor argument. Container options ' +\r\n    'must be an object.';\r\nexport var CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must ' +\r\n    'be a string (\"singleton\" or \"transient\").';\r\nexport var CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = 'Invalid Container option. Auto bind injectable must ' +\r\n    'be a boolean';\r\nexport var CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = 'Invalid Container option. Skip base check must ' +\r\n    'be a boolean';\r\nexport var MULTIPLE_PRE_DESTROY_METHODS = 'Cannot apply @preDestroy decorator multiple times in the same class';\r\nexport var MULTIPLE_POST_CONSTRUCT_METHODS = 'Cannot apply @postConstruct decorator multiple times in the same class';\r\nexport var ASYNC_UNBIND_REQUIRED = 'Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)';\r\nexport var POST_CONSTRUCT_ERROR = function (clazz, errorMessage) { return \"@postConstruct error in class \" + clazz + \": \" + errorMessage; };\r\nexport var PRE_DESTROY_ERROR = function (clazz, errorMessage) { return \"@preDestroy error in class \" + clazz + \": \" + errorMessage; };\r\nexport var ON_DEACTIVATION_ERROR = function (clazz, errorMessage) { return \"onDeactivation() error in class \" + clazz + \": \" + errorMessage; };\r\nexport var CIRCULAR_DEPENDENCY_IN_FACTORY = function (factoryType, serviceIdentifier) {\r\n    return \"It looks like there is a circular dependency in one of the '\" + factoryType + \"' bindings. Please investigate bindings with \" +\r\n        (\"service identifier '\" + serviceIdentifier + \"'.\");\r\n};\r\nexport var STACK_OVERFLOW = 'Maximum call stack size exceeded';\r\n","import * as ERRORS_MSGS from '../constants/error_msgs';\r\nimport * as METADATA_KEY from '../constants/metadata_keys';\r\nfunction injectable() {\r\n    return function (target) {\r\n        if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {\r\n            throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);\r\n        }\r\n        var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];\r\n        Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);\r\n        return target;\r\n    };\r\n}\r\nexport { injectable };\r\n","import { injectable } from 'inversify'\nimport * as fs from 'fs'\nimport * as path from 'path'\nimport { IPublisher, IPublisherOptions } from './publisher.interface'\n\n/**\n * Publisher for publishing assets, views, and translations\n */\n@injectable()\nexport class Publisher implements IPublisher {\n  /**\n   * The registered publishers\n   */\n  private publishers: Map<\n    string,\n    (source: string, target: string, options: IPublisherOptions) => Promise<boolean>\n  > = new Map()\n\n  /**\n   * Create a new publisher\n   */\n  constructor() {\n    // Register default publishers\n    this.registerDefaultPublishers()\n  }\n\n  /**\n   * Create a new publisher\n   *\n   * @returns A new publisher\n   */\n  public static make(): IPublisher {\n    return new Publisher()\n  }\n\n  /**\n   * Register default publishers\n   * @private\n   */\n  private registerDefaultPublishers(): void {\n    // Register asset publisher\n    this.register('assets', this.publishAssets.bind(this))\n\n    // Register views publisher\n    this.register('views', this.publishViews.bind(this))\n\n    // Register translations publisher\n    this.register('translations', this.publishTranslations.bind(this))\n\n    // Register config publisher\n    this.register('config', this.publishConfig.bind(this))\n  }\n\n  /**\n   * Register a publisher\n   *\n   * @param name - The publisher name\n   * @param publisher - The publisher function\n   * @returns The publisher instance\n   */\n  public register(\n    name: string,\n    publisher: (source: string, target: string, options: IPublisherOptions) => Promise<boolean>,\n  ): IPublisher {\n    this.publishers.set(name, publisher)\n    return this\n  }\n\n  /**\n   * Publish assets\n   *\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   * @returns Whether the publishing was successful\n   */\n  public async publishAssets(\n    source: string,\n    target: string,\n    options: IPublisherOptions = {},\n  ): Promise<boolean> {\n    return this.publishDirectory(source, target, options)\n  }\n\n  /**\n   * Publish views\n   *\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   * @returns Whether the publishing was successful\n   */\n  public async publishViews(\n    source: string,\n    target: string,\n    options: IPublisherOptions = {},\n  ): Promise<boolean> {\n    return this.publishDirectory(source, target, options)\n  }\n\n  /**\n   * Publish translations\n   *\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   * @returns Whether the publishing was successful\n   */\n  public async publishTranslations(\n    source: string,\n    target: string,\n    options: IPublisherOptions = {},\n  ): Promise<boolean> {\n    return this.publishDirectory(source, target, options)\n  }\n\n  /**\n   * Publish configuration\n   *\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   * @returns Whether the publishing was successful\n   */\n  public async publishConfig(\n    source: string,\n    target: string,\n    options: IPublisherOptions = {},\n  ): Promise<boolean> {\n    return this.publishDirectory(source, target, options)\n  }\n\n  /**\n   * Publish a directory\n   *\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   * @returns Whether the publishing was successful\n   * @private\n   */\n  private async publishDirectory(\n    source: string,\n    target: string,\n    options: IPublisherOptions = {},\n  ): Promise<boolean> {\n    try {\n      // Create the target directory if it doesn't exist\n      if (!fs.existsSync(target)) {\n        fs.mkdirSync(target, { recursive: true })\n      }\n\n      // Get all files in the source directory\n      const files = this.getFiles(source)\n\n      // Publish each file\n      for (const file of files) {\n        const relativePath = path.relative(source, file)\n        const targetPath = path.join(target, relativePath)\n\n        // Create the target directory if it doesn't exist\n        const targetDir = path.dirname(targetPath)\n        if (!fs.existsSync(targetDir)) {\n          fs.mkdirSync(targetDir, { recursive: true })\n        }\n\n        // Skip if the file exists and force is not enabled\n        if (fs.existsSync(targetPath) && !options.force) {\n          console.log(`Skipping ${targetPath} (already exists)`)\n          continue\n        }\n\n        // Copy the file\n        fs.copyFileSync(file, targetPath)\n        console.log(`Published ${targetPath}`)\n      }\n\n      return true\n    } catch (error) {\n      console.error(`Error publishing directory ${source} to ${target}:`, error)\n      return false\n    }\n  }\n\n  /**\n   * Get all files in a directory recursively\n   *\n   * @param directory - The directory to get files from\n   * @returns The files in the directory\n   * @private\n   */\n  private getFiles(directory: string): string[] {\n    const files: string[] = []\n\n    // Get all entries in the directory\n    const entries = fs.readdirSync(directory, { withFileTypes: true })\n\n    // Process each entry\n    for (const entry of entries) {\n      const fullPath = path.join(directory, entry.name)\n\n      if (entry.isDirectory()) {\n        // Recursively get files from subdirectories\n        files.push(...this.getFiles(fullPath))\n      } else {\n        // Add the file\n        files.push(fullPath)\n      }\n    }\n\n    return files\n  }\n\n  /**\n   * Publish using a registered publisher\n   *\n   * @param name - The publisher name\n   * @param source - The source directory\n   * @param target - The target directory\n   * @param options - The publisher options\n   * @returns Whether the publishing was successful\n   */\n  public async publish(\n    name: string,\n    source: string,\n    target: string,\n    options: IPublisherOptions = {},\n  ): Promise<boolean> {\n    const publisher = this.publishers.get(name)\n\n    if (!publisher) {\n      throw new Error(`Publisher \"${name}\" not found`)\n    }\n\n    return publisher(source, target, options)\n  }\n}\n"]}