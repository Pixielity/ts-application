{"version":3,"sources":["../../src/decorators/abstract-decorator.ts"],"names":[],"mappings":"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","file":"abstract-decorator.mjs","sourcesContent":["import 'reflect-metadata'\nimport type { IClassDecoratorOptions } from '@pixielity/ts-types'\n\n/**\n * Create a class decorator that preserves Inversify metadata\n *\n * @param decorator - The decorator function to apply\n * @param options - Options for the decorator\n * @returns A class decorator function\n *\n * @example\n * ```typescript\n * // Create a simple logging decorator\n * export function LogClass() {\n *   return createClassDecorator((target) => {\n *     console.log(`Class ${target.name} was decorated`);\n *     return target;\n *   });\n * }\n *\n * // Create a decorator with options\n * export function Singleton() {\n *   return createClassDecorator((target) => target, {\n *     beforeConstructor: (target) => {\n *       console.log(`Creating singleton instance of ${target.name}`);\n *     }\n *   });\n * }\n * ```\n */\nexport function createClassDecorator(\n  decorator: (target: any) => any,\n  options: IClassDecoratorOptions = {},\n): ClassDecorator {\n  const {\n    copyPrototype = true,\n    copyStatic = true,\n    copyMetadata = true,\n    beforeConstructor,\n    afterConstructor,\n    transformInstance,\n  } = options\n\n  return (target: any) => {\n    // Apply the decorator to get the modified target\n    const decoratedTarget = decorator(target)\n\n    // If the decorator returns undefined or the same target, no need for the proxy\n    if (decoratedTarget === undefined || decoratedTarget === target) {\n      return target\n    }\n\n    // A utility function to generate instances of a class\n    function construct(constructor: any, args: any[]) {\n      // Run before constructor hook if provided\n      if (beforeConstructor) {\n        beforeConstructor(constructor, args)\n      }\n\n      // Create the instance\n      const instance = new constructor(...args)\n\n      // Run after constructor hook if provided\n      if (afterConstructor) {\n        afterConstructor(instance, constructor, args)\n      }\n\n      // Transform the instance if needed\n      return transformInstance ? transformInstance(instance, constructor, args) : instance\n    }\n\n    // The new constructor behavior\n    const newConstructor: any = (...args: any[]) => construct(decoratedTarget, args)\n\n    // Copy prototype so instanceof operator still works\n    if (copyPrototype) {\n      newConstructor.prototype = decoratedTarget.prototype\n    }\n\n    // Copy static properties\n    if (copyStatic) {\n      Object.getOwnPropertyNames(decoratedTarget).forEach((prop) => {\n        if (prop !== 'prototype' && prop !== 'name' && prop !== 'length') {\n          const descriptor = Object.getOwnPropertyDescriptor(decoratedTarget, prop)\n          if (descriptor) {\n            Object.defineProperty(newConstructor, prop, descriptor)\n          }\n        }\n      })\n    }\n\n    // Copy metadata\n    if (copyMetadata) {\n      const metadataKeys = Reflect.getMetadataKeys(target)\n      metadataKeys.forEach((metadataKey) => {\n        const metadataValue = Reflect.getMetadata(metadataKey, target)\n        Reflect.defineMetadata(metadataKey, metadataValue, newConstructor)\n      })\n    }\n\n    // Return new constructor (will override original)\n    return newConstructor\n  }\n}\n\n/**\n * Create a method decorator\n *\n * @param decorator - The decorator function to apply\n * @returns A method decorator function\n *\n * @example\n * ```typescript\n * // Create a simple logging decorator\n * export function LogMethod() {\n *   return createMethodDecorator((target, propertyKey, descriptor) => {\n *     const original = descriptor.value;\n *     descriptor.value = function(...args: any[]) {\n *       console.log(`Method ${String(propertyKey)} was called with args:`, args);\n *       return original.apply(this, args);\n *     };\n *     return descriptor;\n *   });\n * }\n * ```\n */\nexport function createMethodDecorator(\n  decorator: (\n    target: any,\n    propertyKey: string | symbol,\n    descriptor: PropertyDescriptor,\n  ) => PropertyDescriptor,\n): MethodDecorator {\n  return (target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor) => {\n    // Apply the decorator\n    return decorator(target, propertyKey, descriptor)\n  }\n}\n\n/**\n * Create a property decorator\n *\n * @param decorator - The decorator function to apply\n * @returns A property decorator function\n *\n * @example\n * ```typescript\n * // Create a simple logging decorator\n * export function LogProperty() {\n *   return createPropertyDecorator((target, propertyKey) => {\n *     console.log(`Property ${String(propertyKey)} was decorated`);\n *   });\n * }\n * ```\n */\nexport function createPropertyDecorator(\n  decorator: (target: any, propertyKey: string | symbol) => void,\n): PropertyDecorator {\n  return (target: any, propertyKey: string | symbol) => {\n    // Apply the decorator\n    decorator(target, propertyKey)\n  }\n}\n\n/**\n * Create a parameter decorator\n *\n * @param decorator - The decorator function to apply\n * @returns A parameter decorator function\n *\n * @example\n * ```typescript\n * // Create a simple logging decorator\n * export function LogParameter() {\n *   return createParameterDecorator((target, propertyKey, parameterIndex) => {\n *     console.log(`Parameter ${parameterIndex} of ${String(propertyKey)} was decorated`);\n *   });\n * }\n * ```\n */\nexport function createParameterDecorator(\n  decorator: (\n    target: any,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ) => void,\n): ParameterDecorator {\n  return (target: any, propertyKey: string | symbol | undefined, parameterIndex: number) => {\n    // Apply the decorator\n    decorator(target, propertyKey, parameterIndex)\n  }\n}\n\n/**\n * Abstract decorator base class that can be extended to create custom decorators\n */\nexport abstract class AbstractDecorator {\n  /**\n   * Create a class decorator\n   *\n   * @param options - Options for the decorator\n   * @returns A class decorator function\n   */\n  protected createClassDecorator(options: IClassDecoratorOptions = {}): ClassDecorator {\n    return createClassDecorator((target) => this.decorateClass(target), options)\n  }\n\n  /**\n   * Create a method decorator\n   *\n   * @returns A method decorator function\n   */\n  protected createMethodDecorator(): MethodDecorator {\n    return createMethodDecorator((target, propertyKey, descriptor) =>\n      this.decorateMethod(target, propertyKey, descriptor),\n    )\n  }\n\n  /**\n   * Create a property decorator\n   *\n   * @returns A property decorator function\n   */\n  protected createPropertyDecorator(): PropertyDecorator {\n    return createPropertyDecorator((target, propertyKey) =>\n      this.decorateProperty(target, propertyKey),\n    )\n  }\n\n  /**\n   * Create a parameter decorator\n   *\n   * @returns A parameter decorator function\n   */\n  protected createParameterDecorator(): ParameterDecorator {\n    return createParameterDecorator((target, propertyKey, parameterIndex) =>\n      this.decorateParameter(target, propertyKey, parameterIndex),\n    )\n  }\n\n  /**\n   * Decorate a class\n   *\n   * @param target - The class to decorate\n   * @returns The decorated class\n   */\n  protected abstract decorateClass(target: any): any\n\n  /**\n   * Decorate a method\n   *\n   * @param target - The target object\n   * @param propertyKey - The method name\n   * @param descriptor - The method descriptor\n   * @returns The decorated method descriptor\n   */\n  protected decorateMethod(\n    target: any,\n    propertyKey: string | symbol,\n    descriptor: PropertyDescriptor,\n  ): PropertyDescriptor {\n    return descriptor\n  }\n\n  /**\n   * Decorate a property\n   *\n   * @param target - The target object\n   * @param propertyKey - The property name\n   */\n  protected decorateProperty(target: any, propertyKey: string | symbol): void {\n    // Default implementation does nothing\n  }\n\n  /**\n   * Decorate a parameter\n   *\n   * @param target - The target object\n   * @param propertyKey - The method name\n   * @param parameterIndex - The parameter index\n   */\n  protected decorateParameter(\n    target: any,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ): void {\n    // Default implementation does nothing\n  }\n\n  /**\n   * Create a new abstract decorator\n   *\n   * @returns A new abstract decorator\n   */\n  public static make(): AbstractDecorator {\n    throw new Error('Cannot instantiate abstract class')\n  }\n}\n"]}